### A Pluto.jl notebook ###
# v0.19.40

using Markdown
using InteractiveUtils

# ╔═╡ 4680eed2-dbd8-11ee-17d6-2552317711c1
let
    docs_dir = dirname(dirname(@__DIR__))
    pkg_dir = dirname(docs_dir)

    using Pkg: Pkg
    Pkg.activate(docs_dir)
    Pkg.develop(; path = pkg_dir)
    Pkg.resolve()
    Pkg.instantiate()
end

# ╔═╡ 914b0cd7-86ca-4227-96cb-7cd887956833
begin
    using EpiAware
    using Turing
    using Distributions
    using StatsPlots
    using Random
    using DynamicPPL
    using Statistics
    using DataFramesMeta
    using LinearAlgebra
    using Pathfinder
    using Transducers

    Random.seed!(1)
end;

# ╔═╡ 7c22d80b-2d52-4935-b62d-cbc64437195c
md"
# Getting stated with `EpiAware`

This tutorial introduces the basic functionality of `EpiAware`. `EpiAware` is a package for making inferences on epidemiological case/determined infection data using a model-based approach.
"

# ╔═╡ 683743e6-9426-4b95-994b-4a579aa2564d
md"
## `EpiAware` models
The models we consider are discrete-time $t = 1,\dots, T$ with a latent random process, $Z_t$ generating stochasticity in the number of new infections $I_t$ at each time step. Observations are treated as downstream random variables determined by the actual infections and a model of infection to observation delay.

#### Mathematical definition
```math
\begin{align}
Z_\cdot &\sim \mathcal{P}(\mathbb{R}^T) | \theta_Z, \\
I_0 &\sim f_0(\theta_I), \\
I_t &\sim g_I(\{I_s, Z_s\}_{s < t}, \theta_{I}), \\
y_t &\sim f_O(\{I_s\}_{s \leq t}, \theta_{O}).
\end{align}
```
Where, $\mathcal{P}(\mathbb{R}^T) | \theta_Z$ is a parametric process on $\mathbb{R}^T$. $f_0$ and $f_O$ are parametric distributions on, respectively, the initial number of infections and the observed case data conditional on underlying infections. $g_I$ is distribution of new infections conditional on infections and latent process in the past. Note that we assume that new infections are conditional on the strict past, whereas new observations can depend on infections on the same time step.

#### Code structure outline

An `EpiAware` model in code is created from three modular components:

- A `LatentModel`: This defines the model for $Z_\cdot$. This chooses $\mathcal{P}(\mathbb{R}^T) | \theta_Z$.
- An `EpiModel`: This defines a generative process for infections conditional on the latent process. This chooses $f_0(\theta_I)$, and $g_I(\{I_s, Z_s\}_{s < t}, \theta_{I})$.
- An `ObservationModel`: This defines the observation model. This chooses $f_O({I_s}_{s \leq t}, \theta_{O})$

#### Reproductive number
`EpiAware` models do not need to specify a time-varying reproductive number $\mathcal{R}_t$ to generate $I_\cdot$, however, this is often a quantity of interest. When not directly used we will typically back-calculate $\mathcal{R}_t$ from the generated infections:

```math
\mathcal{R}_t = {I_t \over \sum_{s \geq 1} g_s I_{t-s} }.
```

Where $g_s$ is a discrete generation interval. For this reason, even when not using a reproductive number approach directly, we ask for a generation interval.
"

# ╔═╡ 0b554dd9-79c7-44bc-9cbf-ea56439cb80d
md"
## Random walk `LatentModel`

As an example, we choose the latent process as a random walk with parameters $\theta_Z$:

- ``Z_0``: Initial position.
- ``\sigma^2_{Z}``: The step-size variance.

Conditional on the parameters the random walk is then generated by white noise:
```math
\begin{align}
Z_t &= Z_0 + \sigma_{RW} \sum_{t= 1}^T \epsilon_t, \\
\epsilon_t &\sim \mathcal{N}(0,1).
\end{align}
```

In `EpiAware` we provide a constructor for random walk latent models with priors for $\theta_Z$. We choose priors,
```math
\begin{align}
Z_0 &\sim \mathcal{N}(0,1),\\
\sigma^2_Z &\sim \text{HalfNormal}(0.01).
\end{align}
```
"

# ╔═╡ 65540fb2-f97f-49dc-91f4-af26b803994e
rwp = EpiAware.RandomWalk(Normal(),
    truncated(Normal(0.0, 0.02), 0.0, 0.5))

# ╔═╡ 3ed6eb84-d0e1-4f09-9fa0-4021d0f79f88
md"
## Direct infection `EpiModel`

This is a simple model where the unobserved log-infections are directly generated by the latent process $Z$.
```math
\log I_t = \log I_0 + Z_t.
```

As discussed above, we still ask for a defined generation interval, which can be used to calculate $\mathcal{R}_t$.

"

# ╔═╡ 0a532e52-8305-470a-8462-2aa023b724a2
truth_GI = Gamma(2, 5)

# ╔═╡ ec24d355-0158-45e9-9584-ed89bbb17b31
md"
The `EpiData` constructor performs double interval censoring to convert our _continuous_ estimate of the generation interval into a discretized version. We also implement right truncation using the keyword `D_gen`.
"

# ╔═╡ 8452c589-aceb-41b7-978e-918b83db58d3
model_data = EpiData(truth_GI, D_gen = 10.0)

# ╔═╡ 6028ccd2-428f-4737-9fa6-ab5bf17631bd
md"
We can supply a prior for the initial log_infections.
"

# ╔═╡ bd6714a0-6e70-4602-993e-12238e1f37f2
log_I0_prior = Normal(log(100.0), 1.0)

# ╔═╡ af012cc5-02ea-47f4-8545-cf54f2c6f6cc
md"
And construct the `EpiModel`.
"

# ╔═╡ 18e51238-4038-4022-9b22-0e51ed51ea0a
epi_model = DirectInfections(model_data, log_I0_prior)

# ╔═╡ d75e7957-a020-46f6-8d40-e2ac1abb917f
md"


### Delayed Observations `ObservationModel`

The observation model is a negative binomial distribution with mean `μ` and cluster factor `1 / r`. Delays are implemented
as the action of a sparse kernel on the infections $I(t)$.

```math
\begin{align}
y_t &\sim \text{NegBinomial}(\mu = \sum_{s\geq 0} K[t, t-s] I(s), r), \\
1 / r &\sim \text{Gamma}(3, 0.05/3).
\end{align}
```
"

# ╔═╡ 74771683-48cb-456f-8089-65c2fe2fdef2
md"
We also set up the inference to occur over 100 days.
"

# ╔═╡ cba7072f-aaaa-40fe-8e5f-f22d98fbdb30
time_horizon = 100

# ╔═╡ 6c39de90-4791-42f0-b863-228753618c8a
md"
We choose a simple observation model where infections are observed 0, 1, 2, 3 days later with equal probability.
"

# ╔═╡ b4a420af-71e6-4094-9795-9544dd5f34a2
obs_model = EpiAware.DelayObservations(
    fill(0.25, 4),
    time_horizon,
    truncated(Gamma(5, 0.05 / 5), 1e-3, 0.2)
)

# ╔═╡ 5b667f47-8c90-42ca-8253-998a3ad3878d
md"
## Generate cases from the `EpiAware` model

Having chosen an `EpiModel`, `LatentModel` and `ObservationModel`, we can implement the model as a [`Turing`](https://turinglang.org/dev/) model using  `make_epi_aware`.

By giving `missing` to the first argument, we indicate that case data will be _generated_ from the model rather than treated as fixed.
"

# ╔═╡ 12632c1c-b233-4990-9e7e-9add1bb9a8ee
full_epi_aware_mdl = make_epi_aware(missing, time_horizon;
    epi_model = epi_model,
    latent_model = rwp,
    observation_model = obs_model)

# ╔═╡ 031a55e8-617b-4da4-859c-94b660ec424d
md"
We choose some fixed parameters:
- Initial incidence is 100.
- In the direct infection model, the initial incidence and in the initial value of the random walk form a non-identifiable pair. Therefore, we fix $Z_0 = 0$.
"

# ╔═╡ 775c7295-a4ea-484e-9ad9-291df3f6ffe8
fixed_parameters = (rw_init = 0.0, init_incidence = log(100.0))

# ╔═╡ 5ce1855e-9f9e-4feb-8df3-8ec6139ac943
md"
We fix these parameters using `fix`, and generate a random epidemic.
"

# ╔═╡ 5b86a63b-677c-4125-b0be-1527b73b91bd
cond_generative_model = fix(full_epi_aware_mdl, fixed_parameters)

# ╔═╡ 4a1fc7bb-82a0-4643-a18b-d331a31c1390
random_epidemic = rand(cond_generative_model)

# ╔═╡ e571e7b6-0e26-4855-ae90-05a18be6ff38
true_infections = generated_quantities(cond_generative_model, random_epidemic).I_t

# ╔═╡ 88e8fb2c-38ce-4c68-88b9-c42f3fa6de13
let
    plot(true_infections,
        label = "I_t",
        xlabel = "Time",
        ylabel = "Infections",
        title = "Generated Infections")
    scatter!(random_epidemic.y_t, lab = "generated cases")
end

# ╔═╡ 2f90bee6-067d-4267-beb9-356e4a4d714c
md"
## Inference
Fixing $Z_0 = 0$ for the random walk was based on inference principles; in this model $Z_0$ and $\log I_0$ are non-identifiable.

However, we now treat the generated data as `truth_data` and make inference without fixing any other parameters.

We do the inference by MCMC/NUTS using the `Turing` NUTS sampler with default warm-up steps.
"

# ╔═╡ 7e48a4c5-cd30-4377-8a98-e0c23f2dc31e
truth_data = random_epidemic.y_t

# ╔═╡ 272e6798-1151-486f-9667-924dbc63bd69
inference_mdl = fix(
    make_epi_aware(truth_data, time_horizon;
        epi_model = epi_model,
        latent_model = rwp,
        observation_model = obs_model),
    (init_rw = 0.0,)
)

# ╔═╡ 4298f0ec-f6df-42ee-aa28-f7ed60f1e530
md"
### Initialising inference

It is possible for the default warm-up process for NUTS to get stuck in low probability or otherwise degenerate regions of parameter space.

To make NUTS more robust we provide `manypathfinder`, which is built on pathfinder variational inference through the [Pathfinder.jl](https://mlcolab.github.io/Pathfinder.jl/stable/). `manypathfinder` runs `nruns` pathfinder processes on the inference problem and returns the pathfinder run with maximum estimated ELBO.

`manypathfinder` differs from `Pathfinder.multipathfinder`; `multipathfinder` is aimed at sampling from a potentially non-Gaussian target distribution which is first approximated as a uniformly weighted collection of normal approximations from pathfinder runs. `manypathfinder` is aimed at moving rapidly to a 'good' part of parameter space, and is robust to runs that fail.
"

# ╔═╡ 40ebd47a-4a08-4a46-a727-26347d3fca51
best_pf = manypathfinder(inference_mdl; nruns = 20);

# ╔═╡ b7d9a56a-b2d5-4595-a6b9-9cd5fa6b1445
md"
We can use draws from the best pathfinder run to initialise NUTS.
"

# ╔═╡ cdd805e2-b00c-4522-9261-1819c6a195eb
best_pf.draws_transformed

# ╔═╡ e847b0b6-9d70-46ba-bec6-1e3fa676a33c
init_params = collect.(eachrow(best_pf.draws_transformed.value[1:4, :, 1]))

# ╔═╡ 9734a535-e3d8-4481-9897-f537ad095d21
md"
**NB: We are running this inference run for speed rather than accuracy as a demonstration. Use a higher target acceptance and more samples in a typical workflow.**
"

# ╔═╡ 2fdb4ca6-47ba-4a16-95fa-14b2b32cef10
begin
    target_acc_rate = 0.8
    chn = sample(inference_mdl,
        NUTS(target_acc_rate; adtype = AutoReverseDiff(true)),
        MCMCThreads(),
        250,
        4;
        init_params,
        drop_warmup = true)
end

# ╔═╡ 2e42cb30-b087-4ae1-9b8f-95d103e1c290
md"
### Predictive plotting

We can spaghetti plot generated case data from the version of the model _which hasn't conditioned on case data_ using posterior parameters inferred from the version conditioned on observed data. This is known as _posterior predictive checking_, and is a useful diagnostic tool for Bayesian inference (see [here](http://www.stat.columbia.edu/~gelman/book/BDA3.pdf)).

Because we are using synthetic data we can also plot the model predictions for the _unobserved_ infections and check that (at least in this example) we were able to capture some unobserved/latent variables in the process accurate.
"

# ╔═╡ e74fc652-cd5f-4764-a416-caa8bab0bf0c
let
    post_check_mdl = fix(full_epi_aware_mdl, (init_rw = 0.0,))
    post_check_y_t = mapreduce(hcat, generated_quantities(post_check_mdl, chn)) do gen
        gen.generated_y_t
    end

    predicted_I_t = mapreduce(hcat, generated_quantities(inference_mdl, chn)) do gen
        gen.I_t
    end

    p1 = plot(post_check_y_t, c = :grey, alpha = 0.05, lab = "")
    scatter!(p1, truth_data,
        lab = "Observed cases",
        xlabel = "Time",
        ylabel = "Cases",
        title = "Post. predictive checking: cases",
        ylims = (-0.5, maximum(truth_data) * 1.5),
        c = :green)

    p2 = plot(predicted_I_t, c = :grey, alpha = 0.05, lab = "")
    scatter!(p2, true_infections,
        lab = "Actual infections",
        xlabel = "Time",
        ylabel = "Unobserved Infections",
        title = "Post. predictions: infections",
        ylims = (-0.5, maximum(true_infections) * 1.5),
        c = :red)

    plot(p1, p2,
        layout = (1, 2),
        size = (700, 400))
end

# ╔═╡ 96df9c68-b2e2-4669-b420-5ef23c77aee7
md"
As well as checking the posterior predictions for latent infections, we can also check how well inference recovered unknown parameters, such as the random walk variance or the cluster factor of the negative binomial observations.
"

# ╔═╡ 04d741d8-a2ff-48eb-90b1-e4da416eb582
let
    parameters_to_plot = (:σ²_RW, :neg_bin_cluster_factor)

    plts = map(parameters_to_plot) do name
        var_samples = chn[name] |> vec
        histogram(var_samples,
            bins = 50,
            norm = :pdf,
            lw = 0,
            fillalpha = 0.5,
            lab = "MCMC")
        vline!([getfield(random_epidemic, name)], lab = "True value")
        title!(string(name))
    end
    plot(plts..., layout = (2, 1))
end

# ╔═╡ 42763332-096d-40eb-a152-96e858992ed4
md"
## Reproductive number back-calculation

As mentioned at the top, we _don't_ directly use the concept of reproductive numbers in this note. However, we can back-calculate the implied $\mathcal{R}(t)$ values, conditional on the specified generation interval being correct.

Here we spaghetti plot posterior sampled time-varying reproductive numbers against the actual.
"

# ╔═╡ 3b5a3fa6-fc57-4b3c-b03d-04641bf0e48b
let
    n = epi_model.data.len_gen_int
    Rt_denom = [dot(reverse(epi_model.data.gen_int), true_infections[(t - n):(t - 1)])
                for t in (n + 1):length(true_infections)]
    true_Rt = true_infections[(n + 1):end] ./ Rt_denom

    predicted_Rt = mapreduce(hcat, generated_quantities(inference_mdl, chn)) do gen
        _It = gen.I_t
        _Rt_denom = [dot(reverse(epi_model.data.gen_int), _It[(t - n):(t - 1)])
                     for t in (n + 1):length(_It)]
        Rt = _It[(n + 1):end] ./ _Rt_denom
    end

    plt = plot((n + 1):time_horizon, predicted_Rt, c = :grey, alpha = 0.05, lab = "")
    plot!(plt, (n + 1):time_horizon, true_Rt,
        lab = "true Rt",
        xlabel = "Time",
        ylabel = "Rt",
        title = "Post. predictions: reproductive number",
        c = :red,
        lw = 2)
end

# ╔═╡ Cell order:
# ╟─4680eed2-dbd8-11ee-17d6-2552317711c1
# ╟─914b0cd7-86ca-4227-96cb-7cd887956833
# ╟─7c22d80b-2d52-4935-b62d-cbc64437195c
# ╟─683743e6-9426-4b95-994b-4a579aa2564d
# ╟─0b554dd9-79c7-44bc-9cbf-ea56439cb80d
# ╠═65540fb2-f97f-49dc-91f4-af26b803994e
# ╟─3ed6eb84-d0e1-4f09-9fa0-4021d0f79f88
# ╠═0a532e52-8305-470a-8462-2aa023b724a2
# ╟─ec24d355-0158-45e9-9584-ed89bbb17b31
# ╠═8452c589-aceb-41b7-978e-918b83db58d3
# ╟─6028ccd2-428f-4737-9fa6-ab5bf17631bd
# ╠═bd6714a0-6e70-4602-993e-12238e1f37f2
# ╟─af012cc5-02ea-47f4-8545-cf54f2c6f6cc
# ╠═18e51238-4038-4022-9b22-0e51ed51ea0a
# ╟─d75e7957-a020-46f6-8d40-e2ac1abb917f
# ╟─74771683-48cb-456f-8089-65c2fe2fdef2
# ╠═cba7072f-aaaa-40fe-8e5f-f22d98fbdb30
# ╟─6c39de90-4791-42f0-b863-228753618c8a
# ╠═b4a420af-71e6-4094-9795-9544dd5f34a2
# ╟─5b667f47-8c90-42ca-8253-998a3ad3878d
# ╠═12632c1c-b233-4990-9e7e-9add1bb9a8ee
# ╟─031a55e8-617b-4da4-859c-94b660ec424d
# ╠═775c7295-a4ea-484e-9ad9-291df3f6ffe8
# ╟─5ce1855e-9f9e-4feb-8df3-8ec6139ac943
# ╠═5b86a63b-677c-4125-b0be-1527b73b91bd
# ╠═4a1fc7bb-82a0-4643-a18b-d331a31c1390
# ╠═e571e7b6-0e26-4855-ae90-05a18be6ff38
# ╟─88e8fb2c-38ce-4c68-88b9-c42f3fa6de13
# ╟─2f90bee6-067d-4267-beb9-356e4a4d714c
# ╠═7e48a4c5-cd30-4377-8a98-e0c23f2dc31e
# ╠═272e6798-1151-486f-9667-924dbc63bd69
# ╟─4298f0ec-f6df-42ee-aa28-f7ed60f1e530
# ╠═40ebd47a-4a08-4a46-a727-26347d3fca51
# ╟─b7d9a56a-b2d5-4595-a6b9-9cd5fa6b1445
# ╠═cdd805e2-b00c-4522-9261-1819c6a195eb
# ╠═e847b0b6-9d70-46ba-bec6-1e3fa676a33c
# ╟─9734a535-e3d8-4481-9897-f537ad095d21
# ╠═2fdb4ca6-47ba-4a16-95fa-14b2b32cef10
# ╟─2e42cb30-b087-4ae1-9b8f-95d103e1c290
# ╠═e74fc652-cd5f-4764-a416-caa8bab0bf0c
# ╠═96df9c68-b2e2-4669-b420-5ef23c77aee7
# ╠═04d741d8-a2ff-48eb-90b1-e4da416eb582
# ╠═42763332-096d-40eb-a152-96e858992ed4
# ╠═3b5a3fa6-fc57-4b3c-b03d-04641bf0e48b
